
"use strict"





var is               = require('is')

var constants        = require('jst/commons/constants')
var states           = constants.grammar.tokenStates
var tokeniseSelector = require('jst/selector/scan-selector')





var groupTokens = tokens => {

	return tokens.reduce((acc, token) => {

		if (acc.length === 0 || acc[acc.length - 1].state !== token.state) {

			acc.push(token)

		} else {

			acc[acc.length - 1].char += token.char

		}

		return acc

	}, [ ])

}

var filterStates = (tokens, states) => {

	return tokens.filter(token => {
		return states.indexOf(token.state) === -1
	})

}

var onState = (state, tokens, fn) => {

	onState.precond(state, tokens, fn)

	tokens.forEach(token => {
		token.state === states[state] ? fn(token) : token
	})

	return tokens

}

onState.precond = (state, tokens, fn) => {

	is.always.string(state)
	is.always.array(tokens)

	tokens.forEach(is.always.object)

	is.always.function(fn)

}




var translate = { }




translate.splitRules = tokens => {

	return tokens.reduce((acc, token) => {

		if (token.state === states.RULE_SEPERATOR) {
			acc.push([ ])
		} else {
			acc[acc.length - 1].push(token)
		}

		return acc

	}, [[ ]])

}





translate.checkTypes = tokens => {

	return onState(states.TYPE, tokens, token => {

		if (!constants.grammarEnums.typeMapping.hasOwnProperty(token.char)) {
			throw Error(`selector contains invalid type "${token.char}"`)
		}

	})

}

translate.checkPsuedoclass = tokens => {

	return onState(states.PSEUDOCLASS, tokens, token => {

		if (constants.grammarEnums.psuedoClasses.indexOf(token.char) === -1) {
			throw Error(`selector contains invalid pseudoclass "${token.char}"`)
		}

	})

}

translate.checkOperators = tokens => {

	return onState(states.OPERATOR, tokens, token => {

		if (constants.grammarEnums.operators.indexOf(token.char) === -1) {
			throw Error(`selector contains invalid operator "${token.char}"`)
		}

	})

}

translate.checkEnums = tokens => {
	return translate.checkPsuedoclass(translate.checkTypes(tokens))
}





var patterns;




var recur = (acc, tokens) => {



}





var parseRule = tokens => {
	return recur({ }, tokens)
}





var parseSelector = selector => {

	var tokens       = tokeniseSelector(selector)
	var unusedStates = [
		states.WHITESPACE,
		states.PSEUDOCLASS_OPEN
		states.STRING_OPEN,
		states.STRING_CLOSE
//		states.PSEUDOCLASS_ARGUMENTS_OPEN,
//		states.PSEUDOCLASS_ARGUMENT_SEPERATOR,
//		states.PSEUDOCLASS_ARGUMENTS_CLOSE,
//		states.ATTRIBUTE_OPEN,
//		states.ATTRIBUTE_KEY,
//		states.ATTRIBUTE_CLOSE
	]

	var filtered = filterStates(groupTokens(tokens), unusedStates)

	return translate.splitRules(translate.checkEnums(filtered)).map(parseRule)

}




module.exports = parseSelector







