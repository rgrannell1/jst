
"use strict"





var is               = require('is')

var constants        = require('jst/commons/constants')
var states           = constants.grammar.tokenStates
var tokeniseSelector = require('jst/selector/scan-selector')





var groupTokens = tokens => {

	return tokens.reduce((acc, token) => {

		if (acc.length === 0 || acc[acc.length - 1].state !== token.state) {

			acc.push(token)

		} else {

			acc[acc.length - 1].char += token.char

		}

		return acc

	}, [ ])

}

var filterStates = (tokens, states) => {

	return tokens.filter(token => {
		return states.indexOf(token.state) === -1
	})

}

var onState = (state, tokens, fn) => {

	onState.precond(state, tokens, fn)

	tokens.forEach(token => {
		token.state === states[state] ? fn(token) : token
	})

	return tokens

}

onState.precond = (state, tokens, fn) => {

	is.always.string(state)
	is.always.array(tokens)

	tokens.forEach(is.always.object)

	is.always.function(fn)

}




var translate = { }




translate.splitRules = tokens => {

	return tokens.reduce((acc, token) => {

		if (token.state === states.RULE_SEPERATOR) {
			acc.push([ ])
		} else {
			acc[acc.length - 1].push(token)
		}

		return acc

	}, [[ ]])

}





translate.checkTypes = tokens => {

	return onState(states.TYPE, tokens, token => {

		if (!constants.grammarEnums.typeMapping.hasOwnProperty(token.char)) {
			throw Error(`selector contains invalid type "${token.char}"`)
		}

	})

}

translate.checkPsuedoclass = tokens => {

	return onState(states.PSEUDOCLASS, tokens, token => {

		if (constants.grammarEnums.psuedoClasses.indexOf(token.char) === -1) {
			throw Error(`selector contains invalid pseudoclass "${token.char}"`)
		}

	})

}

translate.checkOperators = tokens => {

	return onState(states.OPERATOR, tokens, token => {

		if (constants.grammarEnums.operators.indexOf(token.char) === -1) {
			throw Error(`selector contains invalid operator "${token.char}"`)
		}

	})

}

translate.checkEnums = tokens => {
	return translate.checkPsuedoclass(translate.checkTypes(tokens))
}





var patterns;




var recur = (acc, tokens) => {

	if (tokens.length === 0) {

		return acc

	} else {

		var token = tokens.shift( )

		if (token.state === states.TYPE) {

			return {
				char:      token.char,
				state:     token.state,

				relation:  'descendant',
				remainder: recur({ }, tokens)
			}

		} else if (token.state === states.OPERATOR) {

			if (tokens.length === 0) {
				throw Error('')
			}

			if (tokens[0].state !== states.TYPE) {
				throw Error('')
			} else {

				var secondToken = tokens[0]

				return {
					char:      secondToken.char,
					state:     secondToken.state,
					relation:  constants.grammarEnums.relations[token.char],
					remainder: recur({ }, tokens)
				}

			}

		} else if (token.state === states.PSEUDOCLASS) {

			var args = [ ]

			if (tokens[0].state === states.PSEUDOCLASS_ARGUMENTS_OPEN) {
				// -- TODO add the pseudoclass and arguments.

				for (var ith = 0; ith < tokens.length; ++ith) {

				}

			}

			return {
				char:  token.char,
				state: token.state,
				pseudoclass: {
					name: tokens[0].char,
					args
				}
			}

		} else if (false) {

		} else {

			throw Error('unmatched state for tokens')

		}

	}

}





var parseRule = tokens => {
	return recur({ }, tokens)
}





var parseSelector = selector => {

	var tokens       = tokeniseSelector(selector)
	var unusedStates = [
		states.WHITESPACE,
		states.PSEUDOCLASS_OPEN
//		states.PSEUDOCLASS_ARGUMENTS_OPEN,
//		states.PSEUDOCLASS_ARGUMENT_SEPERATOR,
//		states.PSEUDOCLASS_ARGUMENTS_CLOSE,
//		states.ATTRIBUTE_OPEN,
//		states.ATTRIBUTE_KEY,
//		states.STRING_OPEN,
//		states.STRING_CLOSE,
//		states.ATTRIBUTE_CLOSE
	]

	var filtered = filterStates(groupTokens(tokens), unusedStates)

	return translate.splitRules(translate.checkEnums(filtered)).map(parseRule)

}




module.exports = parseSelector







