
"use strict"




var csp = require('css-selector-parser').CssSelectorParser



{

	let letters    = [ 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']
	let whitespace = [' ', '	']
	let operators  = ['>', '+', '=', '~']




	var grammar = {
		type:                   { },

		whitespace:             { },
		statementSeparator:     { },
		pseudoclassSeperator:   { },

		openAttributeSelector:  { },
		closeAttributeSelector: { },

		openDoubleString:       { },
		closeDoubleString:      { },

		attribute:              { },
		operator:               { },
		stringValue:            { },

		pseudoclass:            { }
	}





	// -- type-blocks lead to whitespace, pseudoselectors, or attribute selectors.

	letters.forEach(letter => {

		grammar.type[letter]                = 'type'
		grammar.type[letter.toUpperCase( )] = 'type'

	})

	whitespace.forEach(space => {
		grammar.type[space] = 'whitespace'
	})

	grammar.type['*'] = 'type'
	grammar.type[':'] = 'pseudoclassSeperator'
	grammar.type['['] = 'openAttributeSelector'

	// -- open attribute selectors lead to attributes.
	letters.forEach(letter => {

		grammar.openAttributeSelector[letter]                = 'attribute'
		grammar.openAttributeSelector[letter.toUpperCase( )] = 'attribute'

	})

	// -- attribute-blocks lead to operators.

	letters.forEach(letter => {

		grammar.attribute[letter]                = 'attribute'
		grammar.attribute[letter.toUpperCase( )] = 'attribute'

	})

	operators.forEach(operator => {
		grammar.attribute[operator] = 'operator'
	})

	// operators lead to type blocks, or attribute value strings

	letters.forEach(letter => {

		grammar.operator[letter]                = 'type'
		grammar.operator[letter.toUpperCase( )] = 'type'

	})

	grammar.operator['"'] = 'openDoubleString'




	// -- double strings lead to an attribute value, or a close double string.

	grammar.openDoubleString = {
		'"':           "closeDoubleString",
		"**nomatch**": "stringValue"
	}

	grammar.stringValue = {
		'"':           "closeDoubleString",
		"**nomatch**": "stringValue"
	}

	// -- closed double strings lead to close attributes

	grammar.closeDoubleString[']'] = 'closeAttributeSelector'



	// -- whitespace blocks can lead to statement seperators, types.

	whitespace.forEach(space => {
		grammar.whitespace[space] = 'whitespace'
	})

	grammar.whitespace[','] = 'statementSeparator'

	letters.forEach(letter => {

		grammar.whitespace[letter]                = 'type'
		grammar.whitespace[letter.toUpperCase( )] = 'type'

	})


	// -- statement seperators can lead to type-blocks.

	letters.forEach(letter => {

		grammar.statementSeparator[letter]                = 'type'
		grammar.statementSeparator[letter.toUpperCase( )] = 'type'

	})

	grammar.statementSeparator['*'] = 'type'




	// -- psuedoselectors seperators lead to psuedoselector classes

	letters.forEach(letter => {

		grammar.pseudoclassSeperator[letter]                = 'pseudoclass'
		grammar.pseudoclassSeperator[letter.toUpperCase( )] = 'pseudoclass'

	})

	// -- pseudoclass blocks lead to whitespace.

	letters.forEach(letter => {

		grammar.pseudoclass[letter]                = 'pseudoclass'
		grammar.pseudoclass[letter.toUpperCase( )] = 'pseudoclass'

	})

	whitespace.forEach(space => {
		grammar.pseudoclass[space] = 'whitespace'
	})

	grammar.pseudoclass['-'] = 'pseudoclass'




}
console.log( grammar )



var tokeniseCFGrammar = (grammar, chars) => {

	var tokens = [ ]
	var state  = 'type'

	for (var ith = 0; ith < chars.length; ++ith) {

		var char = chars.charAt(ith)

		if (grammar[state].hasOwnProperty(char)) {

			state = grammar[state][char]

		} else if (grammar[state].hasOwnProperty('**nomatch**')) {

			state = grammar[state]['**nomatch**']

		} else {

			var message =
				'no transition from state for "' + char + '"\n' +
				'slice: ' + chars.slice(0, ith + 1) + '\n' +
				'input: ' + chars + '\n'

			throw Error(message)

		}

		tokens.push({char, state})

	}

	return tokens

}





var parseSelector = selector => {

	console.log(
		tokeniseCFGrammar(grammar, selector)
	)

	throw '-- x --'

}





module.exports = parseSelector
