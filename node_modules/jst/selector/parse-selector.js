
"use strict"





var is               = require('is')

var constants        = require('jst/commons/constants')
var states           = constants.states
var tokeniseSelector = require('jst/selector/scan-selector')
var groupTokens      = require('jst/selector/group-tokens')
var filterStates     = require('jst/selector/filter-states')





var onState = (state, tokens, fn) => {

	onState.precond(state, tokens, fn)

	tokens.forEach(token => {
		token.state === states[state] ? fn(token) : token
	})

	return tokens

}

onState.precond = (state, tokens, fn) => {

	is.always.string(state)
	is.always.array(tokens)

	tokens.forEach(is.always.object)

	is.always.function(fn)

}




var translate = { }




translate.splitRules = tokens => {

	return tokens.reduce((acc, token) => {

		if (token.state === states.RULE_SEPERATOR) {
			acc.push([ ])
		} else {
			acc[acc.length - 1].push(token)
		}

		return acc

	}, [[ ]])

}





translate.checkTypes = tokens => {

	return onState(states.TYPE, tokens, token => {

		if (!constants.grammarEnums.typeMapping.hasOwnProperty(token.char)) {
			throw Error(`selector contains invalid type "${token.char}"`)
		}

	})

}

translate.checkPsuedoclass = tokens => {

	return onState(states.PSEUDOCLASS, tokens, token => {

		if (constants.grammarEnums.psuedoClasses.indexOf(token.char) === -1) {
			throw Error(`selector contains invalid pseudoclass "${token.char}"`)
		}

	})

}

translate.checkOperators = tokens => {

	return onState(states.OPERATOR, tokens, token => {

		if (constants.grammarEnums.operators.indexOf(token.char) === -1) {
			throw Error(`selector contains invalid operator "${token.char}"`)
		}

	})

}

translate.checkEnums = tokens => {
	return translate.checkPsuedoclass(translate.checkTypes(tokens))
}





var recur = (acc, tokens) => {

	if (tokens.length === 0) {

		return acc

	} else {

		var token = tokens.shift( )

		if (token.state === states.TYPE) {
			/*

			*/

			return {
				char:      token.char,
				state:     token.state,

				relation:  'descendant',
				remainder: recur({ }, tokens)
			}

		}

		if (token.state === states.OPERATOR) {
			/*

			*/

			if (tokens.length === 0) {
				throw Error('')
			}

			if (tokens[0].state !== states.TYPE) {
				throw Error('')
			} else {

				var secondToken = tokens[0]

				return {
					char:     secondToken.char,
					state:    secondToken.state,
					relation: constants.grammarEnums.relations[token.char]
				}

			}

		}

		if (token.state === states.PSEUDOCLASS) {
			/*

			*/

			if (tokens[0].state === states.PSEUDOCLASS) {
				// -- TODO add the pseudoclass and arguments.

				return {
					char:  token.char,
					state: token.state
				}

			} else {

				return {
					char:  token.char,
					state: token.state
				}

			}

		}

	}

}

var parseRule = tokens => {


	return recur({ }, tokens)

}





var parseSelector = selector => {

	var tokens       = tokeniseSelector(selector)
	var unusedStates = [
		states.WHITESPACE
//		states.PSEUDOCLASS_OPEN,
//		states.PSEUDOCLASS_ARGUMENTS_OPEN,
//		states.PSEUDOCLASS_ARGUMENT_SEPERATOR,
//		states.PSEUDOCLASS_ARGUMENTS_CLOSE,
//		states.ATTRIBUTE_OPEN,
//		states.ATTRIBUTE_KEY,
//		states.STRING_OPEN,
//		states.STRING_CLOSE,
//		states.ATTRIBUTE_CLOSE
	]

	var filtered = filterStates(groupTokens(tokens), unusedStates)

	return translate.splitRules(translate.checkEnums(filtered)).map(parseRule)

}




module.exports = parseSelector







