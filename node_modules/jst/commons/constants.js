
"use strict"





var commons = require('jst/commons/commons')





var constants = {
	messages:      { },
	grammarEnums:  { },
	wildcardToken: '__WILDCARD__',
	grammar:       { }
}





constants.grammar.tokenStates = commons.Enum([

	'TYPE',
	'OPERATOR',

	'WHITESPACE',
	'PSEUDOCLASS_OPEN',
	'PSEUDOCLASS',

	'PSEUDOCLASS_ARGUMENTS_OPEN',

	'PSEUDOCLASS_ARGUMENT_SEPERATOR',

	'PSEUDOCLASS_ARGUMENTS_CLOSE',

	'ATTRIBUTE_OPEN',

	'ATTRIBUTE_KEY',

	'STRING_OPEN',
	'STRING',
	'STRING_CLOSE',

	'ATTRIBUTE_CLOSE',

	'RULE_SEPERATOR'

])




constants.grammar.selectorStates = commons.Enum([
	'OPERATOR',
	'PSEUDOCLASS',
	'PSEUDOCLASS_ARGUMENT_SEPERATOR',
	'PSEUDOCLASS_ARGUMENTS_CLOSE',
	'PSEUDOCLASS_ARGUMENTS_OPEN',
	'RULE_SEPERATOR',
	'STRING_OPEN',
	'STRING',
	'TYPE'
])





constants.grammarEnums.relations = {
	'+': 'next-sibling',
	'~': 'sibling',
	'>': 'descendant'
}





constants.charset = {
	lowerCaseLetters: 'abcdefghijklmnopqrstuvwxyz',
	upperCaseLetters: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
	mixedCaseLetters: 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ',

	colon:             ':',
	numbers:           '0123456789',
	whitespace:        ' 	',
	hypen:             '-',
	operators:         '>+=~',

	comma:             ',',

	openBracket:       '[',
	closeBracket:      ']',

	openRoundBracket:  '(',
	closeRoundBracket: ')',

	doubleString:      '"'
}

Object.keys(constants.charset).forEach(key => {
	constants.charset[key] = constants.charset[key].split('')
})

constants.charset.anyToken = [constants.wildcardToken]




constants.grammarEnums.typeMapping = {
	'array-expr':           ['ArrayExpression'],
	'array-pattern':        ['ArrayPattern'],
	'arrow-expr':           ['ArrowExpression'],
	'assign-expr':          ['AssignmentExpression'],
	'binary-expr':          ['BinaryExpression'],
	'block-stmt':           ['BlockStatement'],
	'break-stmt':           ['BreakStatement'],
	'call-expr':            ['CallExpression'],
	'catch-clause':         ['CatchClause'],
	'comprehension-block':  ['ComprehensionBlock'],
	'comprehension-expr':   ['ComprehensionExpression'],
	'comprehension-if':     ['ComprehensionIf'],
	'conditional-expr':     ['ConditionalExpression'],
	'continue-stmt':        ['ContinueStatement'],
	'debugger-stmt':        ['DebuggerStatement'],
	'declaration':          ['Declaration'],
	'dowhile-stmt':         ['DoWhileStatement'],
	'empty-stmt':           ['EmptyStatement'],
	'expr':                 ['Expression'],
	'expr-stmt':            ['ExpressionStatement'],
	'forin-stmt':           ['ForInStatement'],
	'forof-stmt':           ['ForOfStatement'],
	'for-stmt':             ['ForStatement'],
	'fn':                   ['Function'],
	'fn-declaration':       ['FunctionDeclaration'],
	'fn-expr':              ['FunctionExpression'],
	'generator-expr':       ['GeneratorExpression'],
	'identifier':           ['Identifier'],
	'if-stmt':              ['IfStatement'],
	'labeled-stmt':         ['LabeledStatement'],
	'let-expr':             ['LetExpression'],
	'let-stmt':             ['LetStatement'],
	'literal':              ['Literal'],
	'logical-expr':         ['LogicalExpression'],
	'member-expr':          ['MemberExpression'],
	'new-expr':             ['NewExpression'],
	'object-expr':          ['ObjectExpression'],
	'object-pattern':       ['ObjectPattern'],
	'pattern':              ['Pattern'],
	'position':             ['Position'],
	'program':              ['Program'],
	'property':             ['Property'],
	'return-stmt':          ['ReturnStatement'],
	'sequence-expr':        ['SequenceExpression'],
	'stmt':                 ['Statement'],
	'switch-case':          ['SwitchCase'],
	'switch-expr':          ['SwitchStatement'],
	'this-expr':            ['ThisExpression'],
	'throw-stmt':           ['ThrowStatement'],
	'try-stmt':             ['TryStatement'],
	'unary-expr':           ['UnaryExpression'],
	'update-expr':          ['UpdateExpression'],
	'var-declaration':      ['VariableDeclaration'],
	'var-declarator':       ['VariableDeclarator'],
	'while-stmt':           ['WhileStatement'],
	'with-stmt':            ['WithStatement'],
	'yield-expr':           ['YieldExpression']
}

constants.grammarEnums.psuedoClasses = [
	'first',
	'second',
	'third',
	'fourth',

	'first-child',
	'not',
	'nth-child',
	'only-child'
]

constants.grammarEnums.operators = [
	'>',
	'+',
	'~'
]





module.exports = constants
